# Context Guided Search

Основная статья - How We Get There: A Context-Guided Search Strategy in Concolic Testing

Основные тезисы:
* Явно строим execution tree
* k-Контекст ветви: последние k узлов ветви
* Мы используем те ветви, которых нет в кэше контекстов.
* Контекст считается на ветви без доминирующих блоков.
* Блок D доминирует на блоком M, если любой путь к M проходит через D.

---

Модуль: org.jetbrains.research.kex.asm.analysis.concolic

Основные изменения: ConcolicChecker.kt, TraceGraph.kt

## Алгоритм

Для каждой ветви Context Guided Search (CGS) решает, стоит ли делать для неё concolic run,
либо же пропустить его. Решение выносится на основе того, присутствует ли k-контекст ветви в кэше контекстов,
который содержит контексты всех исполненных ветвей. В ходе исполнения k меняется от 1 до бесконечности.

Таким образом, получим следующий алгоритм
```
tree = initTree(startExecutionPath)
k = 1
while not terminated:
    branches = tree.getBranches()
    paths = branches
        .filter(its k-context is not new)
        .filter(it has not been selected before)
        .map(concolic run)
        .filter(acquired sat)
    add paths to tree
    k += 1
```   

Этот алгоритм отличается от приведённого в статье тем, что оригинальный, по сути,
использует отсортированные по длине branches. Какого-то обоснования этому на практике я не нашёл.

### Построение контекстов

Контексты строятся как хвост определённой длины для ветви:

(Для просмотра графов может понадобиться dotplugin и подключение PlantUML в Settings Markdown)
```plantuml
digraph NonDom {
A -> B -> C -> D  -> E -> F -> G -> K [fillcolor=red]
F -> H -> K [fillcolor=green]
}
```

Как мы видим, здесь контексты ветвей различаются уже на глубине 2 и мы быстро сможем их отличить.
Однако в следующем примере ситуация другая: 


```plantuml
digraph NonDom {
A -> B -> D  -> E -> F -> G -> H [fillcolor=red]
A -> C -> D [fillcolor=green]
}
```

Здесь мы видим, что левая и правая ветви отличаются тоже лишь в одном блоке, но это отличие мы обнаружим не скоро. 
Чтобы получить их оптимальное различие в контекстах, хочется убрать все узлы, которые не вносят никакой полезной информации в контекст. 
Такими узлами оказываются узлы-доминаторы.

### Устранение доминаторов  

Блок D доминирует на блоком M, если любой путь к M проходит через D.

Таким образом, доминатор для узла $n$ можно отыскать с помощью следующего уравнения:

```
Dom(n0) = n0
Dom(n) = n union n.predecessors.map(Dom).reduce(intersect)
``` 

Таким образом, предыдущий граф для вычисления контекстов представляется как
```plantuml
digraph NonDom {
A -> B -> H [fillcolor=red]
A -> C -> H [fillcolor=green]
}
```

## Реализация

Мы явно задаём Execution Tree, который реализуется как `TraceGraph` и используется для того, чтобы вычислять контексты.
Таким образом, основным методом `TraceGraph` становится `getTracesAndBranches()`, возвращающий `Trace` и ассоциированную с ним ветвь графа.

Наследником данного класса является `DominatorTraceGraph`, который возвращает ветви без узлов-доминаторов.

### Формальное равенство `Action`

При добавлении новых узлов в `TraceGraph` нам необходимо сравнивать новые и старые узлы. 
Для этого был введен абстрактный метод `formalEquals`, который сравнивает формальные характеристики реализаций `Action`.

### Добавление новой ветви в граф

Основа добавления `Trace` в граф реализуется достаточно просто: зацепляем неизвестные участки входного `Trace` к известным узлам.
Для того, чтобы делать это корректно, рассмотрим несколько крайних случаев.

#### Последовательные формально эквивалентные блоки
Пусть узлы `C` и `G` - формально равны.
Тогда, при добавлении правой ветки возникает вопрос - куда цеплять узел `M`?
Чтобы разрешить эту проблему, будем запоминать все использованные при добавлении узлы и более их не искать.
Реализуется как работа с `foundVerticesStack`.
```plantuml
digraph NonDom {
C [color=red];
G [color=red];
A [shape = doublecircle];
K [shape = doublecircle];
H [shape = doublecircle];
M [shape = doublecircle];
A -> B -> C -> D -> E -> F -> G -> H [fillcolor=red];
K -> B -> C -> D -> L -> F -> G -> M [fillcolor=green];
}
```

#### Формально эквивалентные блоки в разных функциях
Пусть имеется 2 функции, содержащие формально эквивалентные блоки `E` и `N`. 
Тогда, при добавлении правой ветви нужно использовать пространство блоков только текущей функции.
Реализуется как работа с `methodStack`

```plantuml
digraph G {

	subgraph cluster_0 {
		D -> E -> F;
		label = "func #1";
	};

    subgraph cluster_1 {
        M -> N -> O;
        label = "func #2";
    };


	A -> B [fillcolor=red];
    L -> B [fillcolor=green];
    B -> C [fillcolor=red];
    C -> D [fillcolor=red];
    C -> M [fillcolor=green];
    F -> G [fillcolor=red];
    O -> G [fillcolor=green];
    G -> H [fillcolor=red];
    H -> K [fillcolor=red];
    H -> P [fillcolor=green];

    A [shape = doublecircle];
    L [shape = doublecircle];
    K [shape = doublecircle];
    P [shape = doublecircle];

    E [color=red];
    N [color=red];
    
}
```

## Статистика

Логика статистки находится в kex.statistics и реализованна как data class со следующими полями:
* Название алгоритма (указывается при создании)
* Полное имя метода
* Число итераций
* Затраченное время
* Число concolic run, которые закончились SAT

Чтобы справляться с асинхронностью, статистика по методам буферизуется в статического `Map` и в конце работы записывается в файл.

### Число итераций: Random vs CGS

Для Random мы можем ожидать ситуации, когда SAT достичь бывает сложно, но это компенсируется легковесными итерациями, которых за ограниченное время проходит достаточно много.

В случае CGS мы ожидаем дорогие итерации, которые смогут выдавать SAT чаще.

### Измерения

Сейчас сменил логику на более корректную. TODO  
 